<h1 align="center">Переводчик</h1>

Кто такие переводчики? Это люди, помогающие общаться носителям разных языков.
Данный проект посвящен похожей процедуре - он показывает, какими способами
могут общаться между собой программы, написанные на разных языках программирования.

---

<h3 align="center">Способы взаимодействия</h3>

В качестве "переводчиков", которые позволят общаться нашим программам,
мы будем использовать следующие технологии:

- Стандартные HTTP запросы
- WebSockets
- gRPC
- Общий доступ к базе данных SQLite
- JNI

Помимо общения между приложениями, эти технологии также производят передачу данных,
поэтому этот процесс будет также рассмотрен. Теперь немного про каждое средство:

1. **HTTP запросы.** Это способ взаимодействия между клиентом и сервером через протокол
HTTP. Используется модель запрос-ответ, где клиент отправляет запрос на сервер,
а сервер возвращает ответ. Это самый распространенный способ взаимодействия двух
приложений;
2. **WebSockets.** Это протокол для установления постоянного двустороннего соединения
между клиентом и сервером поверх одного TCP-соединения. В отличие от HTTP, который
использует модель запрос-ответ, WebSockets позволяют обеим сторонам обмениваться
данными в реальном времени без необходимости повторного открытия соединения;
3. **gRPC.** Это современный RPC (Remote Procedure Call) фреймворк, разработанный Google,
который использует Protocol Buffers для сериализации данных и HTTP/2 для передачи
данных;
4. **Общий доступ к базе данных.** Этот способ предполагает использование одной и той же
базы данных несколькими программами для обмена данными. Так как весь проект будет
развернут на одном хосте, для примера достаточно будет использования СУБД SQLite,
которая хранит всю информацию в одном файле с расширением `.db`. В сравнении будет
рассматриваться общий случай использования баз данных, которые, как правило,
поддерживают доступ по сети и одновременное чтение данных несколькими пользователями;
5. **JNI (Java Native Interface).** Это интерфейс программирования, который позволяет
Java коду взаимодействовать с нативными библиотеками, написанными на C или C++.
Этот способ может использоваться для улучшения производительности или доступа к
низкоуровневым системным ресурсам.

<h3 align="center">Сравнение способов взаимодействия</h3>

Для более подробного сравнения способов передачи данных между приложениями,
рассмотрим у них несколько критериев:
- поддержка языков программирования;
- типы данных;
- возможность работы по сети;
- безопасность при передаче данных.

Сначала рассмотрим первые 2 характеристики:

<table>
    <thead>
        <tr>
            <th>Способ взаимодействия</th>
            <th>Поддерживаемые языки</th>
            <th>Типы данных</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>HTTP запросы</td>
            <td>Все современные языки</td>
            <td>JSON, XML, HTML и т.д.</td>
        </tr>
        <tr>
            <td>WebSockets</td>
            <td>Все современные языки</td>
            <td>Текст, бинарные данные</td>
        </tr>
        <tr>
            <td>gRPC</td>
            <td>C#, C++, Dart, Go, Java, Kotlin, Node.js,
                Objective-C, PHP, Python, и Ruby</td>
            <td>Protocol Buffers</td>
        </tr>
        <tr>
            <td>Общий доступ к БД</td>
            <td>Все современные языки</td>
            <td>Зависит от выбранной СУБД</td>
        </tr>
        <tr>
            <td>JNI</td>
            <td>Только из Java можно вызывать функции на C/C++</td>
            <td>Примитивы, структуры</td>
        </tr>
    </tbody>
</table>

Как можно заметить, в случае с некоторыми языками, выбор становится более узким.
В целом, это не проблема. JNI все-таки является особенностью и преимуществом Java,
а все самые удобные методы доступны для всех современных языков программирования.
Что касается типов данных, все привыкли к строкам, целым числам, числам с плавающей
точкой и т.д. В HTTP эти типы поддерживаются форматом JSON, но все равно преобразуются
в строки для передачи, что увеличивает размер сообщений. Для Веб-сокетов нужно
использовать одинаковые сериализаторы и десериализаторы и передавать данные в двоичном
виде. Protobuf, JNI и все популярные СУБД также поддерживают привычнын нам примитивы.

Для общего понимания, рассмотрим возможности работы по сети и защиту передачи данных.

<table>
    <thead>
        <tr>
            <th>Способ взаимодействия</th>
            <th>Работа по сети</th>
            <th>Безопасность</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>HTTP запросы</td>
            <td>Есть</td>
            <td>TLS/SSL</td>
        </tr>
        <tr>
            <td>WebSockets</td>
            <td>Есть</td>
            <td>TLS/SSL</td>
        </tr>
        <tr>
            <td>gRPC</td>
            <td>Есть</td>
            <td>TLS/SSL</td>
        </tr>
        <tr>
            <td>Общий доступ к БД</td>
            <td>Есть почти у всех СУБД</td>
            <td>TLS/SSL + система авторизации самой СУБД</td>
        </tr>
        <tr>
            <td>JNI</td>
            <td>Отсутствует</td>
            <td>Не требуется, так как работает локально</td>
        </tr>
    </tbody>
</table>

JNI выделяется среди остальных, но, опять же, он служит как фишка языка Java, и
не используется для удаленного соединения. В остальном тут все понятно.

<h3 align="center">Используемые языки</h3>

В качестве языков, на которых будут написаны программы, которые мы будем "дружить"
между собой, были выбраны `Java`, `C++`, `Rust`, `JavaScript`, `Python` и `Go`. На
картинке показано, каким именно образом они будут связаны.

<div align="right">Схема коммуникации</div>

![lang_schema](assets/schema.png)

<h3 align="center">Архитектура</h3>

Как вообще это все будет работать. Мы будем передавать 2 параметра всеми пятью способами:
массив целых чисел и какую-нибудь строку. Для этого, на одном конце будет веб-страница
с JavaScript кодом, который будет передавать введеные на странице данные (массив и
строку) по HTTP на локальный порт, на котором будет работать веб-сервер на Rust.
Он, в свою очередь, как и все остальные приложения, будет делать одну простую операцию
с этими данными - сдвигать циклично массив и строку вправо на 1 элемент и передавать
их дальше. На другом конце, код на C++ будет объединять эти данные в одну строку и
передавать их обратно. В итоге, на первоначальной веб-странице отобразится
получившаяся в результате многократных преобразования строка. Все это просто тестовый
пример обработки информации, для нас главное - заставить все приложения общаться между
собой.

<h3 align="center">JavaScript</h3>

Начнем с веб-страницы, принимающей входные данные и передающей их дальше. Заранее
определим, что веб-сервер на Rust будет работать на порту `8101`. Это потребуется
для указания адреса в параметре запроса в функции на JavaScript. Итого нам потребуется:
[HTML](JavaScript/index.html)-код для создания элементов ввода на странице,
[CSS](JavaScript/style.css)-код для стилизации этих элементов и
[JavaScript](JavaScript/script.js)-код для преобразования и отправки данных, а также
для функционирования кнопок.

Тут все просто. В JavaScript для отправки данных по HTTP
используется метод `fetch()`. При отправке формы происходит перехват события `submit`
с помощью `event.preventDefault()`, чтобы предотвратить стандартное поведение формы.
Затем собираются данные из текстового поля и массива чисел, формируя объект `data`,
который конвертируется в JSON-формат с помощью `JSON.stringify()`. Запрос отправляется
методом POST на локальный хост с портом `8101` с заголовком
`Content-Type: application/json` для указания типа отправляемых данных.
Ответ сервера обрабатывается с использованием промисов (`then` и `catch`) для обработки
успешного ответа или ошибок. Ниже показан внешний вид формы.

<div align="right">Форма ввода данных</div>
<div align="center">
    <img src="assets/web-page.png" alt="web-page">
</div>

Отправленные данные в формате JSON:
```json
{
  "text": "input_string",
  "array": [
    0,
    56,
    -100,
    1,
    17
  ]
}
```




<h5 align="right">Прохоров Тимофей</h5>